//+------------------------------------------------------------------+
//|                                                  AdaptiveEA.mq5  |
//|                        Example Expert Advisor using ML signals   |
//+------------------------------------------------------------------+
#property copyright "OpenAI"
#property version   "1.00"
#property strict

#include <Trade/Trade.mqh>
CTrade trade;

input string ModelSignalFile = "signals.csv"; // CSV generated by Python model
input double RiskPerTrade = 0.01;
input int TrailingStopPips = 20;
input double MaxDailyLoss = 3.0;   // percent
input double MaxDrawdown = 10.0;   // percent
input int    RiskLookbackBars = 50;      // bars used to estimate risk
input bool   UseSharpeSizing   = true;   // scale position size by Sharpe ratio
input double MinRiskFactor     = 0.5;    // lower bound for position multiplier
input double MaxRiskFactor     = 2.0;    // upper bound for position multiplier
input int    VarLookbackBars   = 50;     // bars used for VaR/stress calc
input double MaxVaR            = 5.0;    // max allowed 99% VaR in percent
input double MaxStressLoss     = 15.0;   // max allowed stress loss percent
input double MaxCVaR           = 7.5;    // max allowed expected shortfall
input int    ShortVolPeriod    = 10;     // short-term volatility bars
input int    LongVolPeriod     = 50;     // long-term volatility bars
input int    SignalTimeTolerance = 60;   // seconds tolerance for matching signals

double peak_equity = 0.0;
double day_start_equity = 0.0;
datetime last_day = 0;
bool trading_allowed = true;

bool LoadSignal(datetime time, double &prob)
{
   int fh = FileOpen(ModelSignalFile, FILE_READ|FILE_CSV|FILE_ANSI);
   if(fh == INVALID_HANDLE)
      return(false);
   datetime closest_time = 0;
   double   closest_prob = 0;
   bool     found = false;
   while(!FileIsEnding(fh))
   {
      datetime t = (datetime)FileReadString(fh);
      double p = FileReadNumber(fh);
      int diff = (int)MathAbs(time - t);
      if(diff <= SignalTimeTolerance)
      {
         if(!found || diff < MathAbs(time - closest_time))
         {
            closest_time = t;
            closest_prob = p;
            found = true;
         }
      }
   }
   FileClose(fh);
   if(found)
   {
      prob = closest_prob;
      return(true);
   }
   return(false);
}

double CalculateRiskFactor()
{
   int count=MathMin(RiskLookbackBars,Bars(Symbol(),PERIOD_CURRENT)-1);
   if(count<=1)
      return(1.0);

   double mean=0.0;
   for(int i=0;i<count;i++)
      mean+=(Close[i]-Close[i+1])/Close[i+1];
   mean/=count;

   double var=0.0;
   for(int i=0;i<count;i++)
   {
      double ret=(Close[i]-Close[i+1])/Close[i+1];
      var+=MathPow(ret-mean,2);
   }
   double sd=MathSqrt(var/count);
   if(sd==0.0)
      return(1.0);

   double factor;
   if(UseSharpeSizing)
   {
      double sharpe=mean/sd;
      factor=1.0+sharpe;
   }
   else
   {
      factor=1.0/(1.0+sd*100.0);
   }

   double regime = RegimeMultiplier();

   if(factor<MinRiskFactor)
      factor=MinRiskFactor;
   if(factor>MaxRiskFactor)
      factor=MaxRiskFactor;

   return(factor*regime);
}

double RegimeMultiplier()
{
   int short_n=MathMin(ShortVolPeriod,Bars(Symbol(),PERIOD_CURRENT)-1);
   int long_n=MathMin(LongVolPeriod,Bars(Symbol(),PERIOD_CURRENT)-1);
   if(long_n<=1 || short_n<=1)
      return(1.0);

   double mean_s=0.0, mean_l=0.0;
   for(int i=0;i<short_n;i++)
      mean_s+=(Close[i]-Close[i+1])/Close[i+1];
   mean_s/=short_n;
   for(int i=0;i<long_n;i++)
      mean_l+=(Close[i]-Close[i+1])/Close[i+1];
   mean_l/=long_n;

   double var_s=0.0, var_l=0.0;
   for(int i=0;i<short_n;i++)
   {
      double r=(Close[i]-Close[i+1])/Close[i+1];
      var_s+=MathPow(r-mean_s,2);
   }
   for(int i=0;i<long_n;i++)
   {
      double r=(Close[i]-Close[i+1])/Close[i+1];
      var_l+=MathPow(r-mean_l,2);
   }
   double sd_s=MathSqrt(var_s/short_n);
   double sd_l=MathSqrt(var_l/long_n);
   if(sd_l==0.0)
      return(1.0);
   double ratio=sd_s/sd_l;
   if(ratio>1.5)
      return(0.5);
   if(ratio<0.7)
      return(1.2);
   return(1.0);
}

double CalculateVaR()
{
   int count=MathMin(VarLookbackBars,Bars(Symbol(),PERIOD_CURRENT)-1);
   if(count<=1)
      return(0.0);
   double arr[];
   ArrayResize(arr,count);
   for(int i=0;i<count;i++)
      arr[i]=(Close[i]-Close[i+1])/Close[i+1];
   ArraySort(arr,WHOLE_ARRAY,0,MODE_ASCEND);
   int idx=(int)MathFloor(0.01*count);
   double var=-arr[idx]*100.0;
   return(var);
}

double CalculateCVaR()
{
   int count=MathMin(VarLookbackBars,Bars(Symbol(),PERIOD_CURRENT)-1);
   if(count<=1)
      return(0.0);
   double arr[];
   ArrayResize(arr,count);
   for(int i=0;i<count;i++)
      arr[i]=(Close[i]-Close[i+1])/Close[i+1];
   ArraySort(arr,WHOLE_ARRAY,0,MODE_ASCEND);
   int idx=(int)MathFloor(0.01*count);
   double sum=0.0;
   for(int i=0;i<=idx;i++)
      sum+=arr[i];
   double cvar=-(sum/(idx+1))*100.0;
   return(cvar);
}

double CalculateStressLoss()
{
   int count=MathMin(VarLookbackBars,Bars(Symbol(),PERIOD_CURRENT)-1);
   if(count<=1)
      return(0.0);
   double mean=0.0;
   for(int i=0;i<count;i++)
      mean+=(Close[i]-Close[i+1])/Close[i+1];
   mean/=count;
   double variance=0.0;
   for(int i=0;i<count;i++)
   {
      double r=(Close[i]-Close[i+1])/Close[i+1];
      variance+=MathPow(r-mean,2);
   }
   double sd=MathSqrt(variance/count);
   return(3.0*sd*100.0);
}

void CloseAllPositions()
{
   while(PositionSelect(Symbol()))
   {
      ulong ticket=PositionGetTicket(0);
      trade.PositionClose(ticket);
   }
}

void UpdateRisk()
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   if(equity>peak_equity)
      peak_equity=equity;

   datetime today = Date();
   if(today!=last_day)
   {
      day_start_equity=equity;
      last_day=today;
      trading_allowed=true;
   }

   double day_loss_pct=(equity-day_start_equity)/day_start_equity*100.0;
   double drawdown_pct=(equity-peak_equity)/peak_equity*100.0;
   double var_pct=CalculateVaR();
   double cvar_pct=CalculateCVaR();
   double stress_pct=CalculateStressLoss();
   if(day_loss_pct<=-MaxDailyLoss || drawdown_pct<=-MaxDrawdown)
   {
      CloseAllPositions();
      trading_allowed=false;
   }
   if(var_pct>MaxVaR || stress_pct>MaxStressLoss || cvar_pct>MaxCVaR)
   {
      CloseAllPositions();
      trading_allowed=false;
   }
}

void OnTick()
{
   static datetime last_time=0;
   if(TimeCurrent()==last_time)
      return;
   last_time=TimeCurrent();

   UpdateRisk();
   if(!trading_allowed)
      return;

   double prob;
   if(!LoadSignal(TimeCurrent(), prob))
      return;

   if(PositionSelect(Symbol())==false && prob>0.55)
   {
      double risk_factor=CalculateRiskFactor();
      double volume=NormalizeDouble(AccountBalance()*RiskPerTrade*risk_factor/1000,2);
      trade.Buy(volume,NULL,Ask,0,0);
   }

   if(PositionSelect(Symbol()))
   {
      ulong ticket=PositionGetTicket(0);
      double stop=PositionGetDouble(POSITION_SL);
      double price=SymbolInfoDouble(Symbol(),SYMBOL_BID);
      double new_stop=price - TrailingStopPips*_Point;
      if(new_stop>stop)
         trade.PositionModify(ticket,new_stop,0);
   }
}
