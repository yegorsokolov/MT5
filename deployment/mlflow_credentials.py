"""Generate MLflow tracking credentials and persist them to an env file.

The trading stack expects ``secret://MLFLOW_USER`` and ``secret://MLFLOW_PASS``
to resolve to a service account that has read/write access to the tracking
server. Previously these values had to be filled in manually inside ``.env``.
This helper automates that bootstrap by minting random credentials, storing
them alongside other runtime secrets and printing export commands for shell
usage when requested.

Example usage::

    python -m deployment.mlflow_credentials \\
        --env-file deploy/secrets/runtime.env \\
        --print-exports

The script is idempotent – existing credentials are reused unless explicitly
rotated.  Operators can therefore run it as part of their provisioning pipeline
without worrying about accidental secret changes.
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from datetime import datetime, timezone
import os
from pathlib import Path
import secrets
import string
import sys
from typing import Dict, Mapping, Sequence


MLFLOW_USER_KEY = "MLFLOW_USER"
MLFLOW_PASS_KEY = "MLFLOW_PASS"

DEFAULT_ENV_FILE = Path(".env")


@dataclass
class CredentialResult:
    """Outcome of ensuring MLflow credentials exist."""

    path: Path
    values: Dict[str, str]
    created: list[str]
    rotated: list[str]
    written: bool


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate MLflow tracking credentials")
    parser.add_argument(
        "--env-file",
        default=str(DEFAULT_ENV_FILE),
        help="Path to the env file that should receive MLFLOW_USER/MLFLOW_PASS (default: .env)",
    )
    parser.add_argument(
        "--username",
        help="Optional username to set. Defaults to a random mlflow-<token> identifier.",
    )
    parser.add_argument(
        "--rotate-username",
        action="store_true",
        help="Generate a fresh username or allow overwriting the existing one when --username is provided.",
    )
    parser.add_argument(
        "--rotate-password",
        action="store_true",
        help="Always generate a fresh password even if one already exists.",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing values without prompting for rotation flags.",
    )
    parser.add_argument(
        "--print-exports",
        action="store_true",
        help="Print the managed secrets as 'export KEY=VALUE' for shell usage.",
    )
    return parser.parse_args(argv)


def _read_env_file(path: Path) -> Dict[str, str]:
    values: Dict[str, str] = {}
    if not path.exists():
        return values
    with path.open("r", encoding="utf-8") as handle:
        for raw_line in handle:
            line = raw_line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            values[key.strip()] = value.strip()
    return values


def _random_username() -> str:
    token = "".join(secrets.choice(string.ascii_lowercase + string.digits) for _ in range(10))
    return f"mlflow-{token}"


def _random_password(length: int = 32) -> str:
    alphabet = string.ascii_letters + string.digits
    return "".join(secrets.choice(alphabet) for _ in range(length))


def _write_env_file(
    path: Path,
    *,
    managed_values: Mapping[str, str],
    existing: Mapping[str, str],
    force: bool,
) -> bool:
    merged: Dict[str, str] = dict(existing)
    changed = False
    for key, value in managed_values.items():
        current = merged.get(key)
        if current == value:
            continue
        if current is not None and not force:
            raise RuntimeError(
                f"Secret {key} already exists – rerun with --rotate-* or --force to overwrite it."
            )
        merged[key] = value
        changed = True

    if not changed and all(key in merged for key in managed_values):
        return False

    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    lines = [
        "# MLflow credentials generated by deployment.mlflow_credentials",
        f"# Updated {timestamp}",
        "#",
        "# Credentials for authenticated MLflow tracking servers.",
        f"{MLFLOW_USER_KEY}={merged[MLFLOW_USER_KEY]}",
        f"{MLFLOW_PASS_KEY}={merged[MLFLOW_PASS_KEY]}",
        "",
    ]

    preserved = [
        (key, merged[key])
        for key in sorted(merged)
        if key not in (MLFLOW_USER_KEY, MLFLOW_PASS_KEY) and not key.startswith("#")
    ]
    if preserved:
        lines.append("# Additional entries preserved from previous runs")
        for key, value in preserved:
            lines.append(f"{key}={value}")
        lines.append("")

    content = "\n".join(lines).rstrip() + "\n"

    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as handle:
        handle.write(content)
    try:
        os.chmod(path, 0o600)
    except OSError:
        pass
    return True


def ensure_mlflow_credentials(
    env_path: Path,
    *,
    username: str | None = None,
    rotate_username: bool = False,
    rotate_password: bool = False,
    force: bool = False,
) -> CredentialResult:
    existing = _read_env_file(env_path)

    current_user = existing.get(MLFLOW_USER_KEY)
    current_pass = existing.get(MLFLOW_PASS_KEY)

    managed: Dict[str, str] = {}
    created: list[str] = []
    rotated: list[str] = []

    if username:
        target_user = username
    elif current_user is None or rotate_username or force:
        target_user = _random_username()
    else:
        target_user = current_user

    if current_user is None:
        created.append(MLFLOW_USER_KEY)
    elif target_user != current_user:
        if not (rotate_username or force or username == current_user):
            raise RuntimeError(
                "MLFLOW_USER already exists – use --rotate-username, --force or provide the same --username."
            )
        rotated.append(MLFLOW_USER_KEY)

    managed[MLFLOW_USER_KEY] = target_user

    if current_pass is None or rotate_password or force:
        target_pass = _random_password()
    else:
        target_pass = current_pass

    if current_pass is None:
        created.append(MLFLOW_PASS_KEY)
    elif target_pass != current_pass:
        if not (rotate_password or force):
            raise RuntimeError(
                "MLFLOW_PASS already exists – use --rotate-password or --force to generate a new one."
            )
        rotated.append(MLFLOW_PASS_KEY)

    managed[MLFLOW_PASS_KEY] = target_pass

    final_values = dict(existing)
    final_values.update(managed)

    written = _write_env_file(
        env_path,
        managed_values=managed,
        existing=existing,
        force=force or rotate_username or rotate_password,
    )
    if written and not final_values:
        final_values = _read_env_file(env_path)

    return CredentialResult(
        path=env_path,
        values=final_values,
        created=created,
        rotated=rotated,
        written=written,
    )


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    env_path = Path(args.env_file).expanduser()
    try:
        result = ensure_mlflow_credentials(
            env_path,
            username=args.username,
            rotate_username=args.rotate_username,
            rotate_password=args.rotate_password,
            force=args.force,
        )
    except RuntimeError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    if args.print_exports:
        for key in (MLFLOW_USER_KEY, MLFLOW_PASS_KEY):
            value = result.values.get(key)
            if value is not None:
                print(f"export {key}='{value}'")

    if result.rotated:
        print(f"Rotated {', '.join(result.rotated)} in {result.path}")
    elif result.created:
        print(f"Wrote {result.path} with {len(result.created)} new secrets")
    elif result.written:
        print(f"Updated {result.path}")
    else:
        print(f"{result.path} already contained MLflow credentials")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    sys.exit(main())
