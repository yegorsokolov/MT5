//+------------------------------------------------------------------+
//|                                                  RealtimeEA.mq5  |
//|      Example EA that loads model signals and auto-updates repo   |
//+------------------------------------------------------------------+
#property copyright "OpenAI"
#property version   "1.00"
#property strict

#include <Trade/Trade.mqh>
#import "shell32.dll"
int ShellExecuteW(int hwnd,string lpOperation,string lpFile,string lpParameters,string lpDirectory,int nShowCmd);
#import

CTrade trade;

input string RepoPath = "C:\\Path\\To\\TriangleBot\\MT5"; // local repo path
input string ModelSignalFile = "signals.csv"; // generated by Python
input double RiskPerTrade = 0.01;
input int TrailingStopPips = 20;
input double MaxDailyLoss = 3.0;   // percent
input double MaxDrawdown = 10.0;   // percent
input int    RiskLookbackBars = 50;      // bars used to estimate risk
input bool   UseSharpeSizing   = true;   // scale position size by Sharpe ratio
input double MinRiskFactor     = 0.5;    // lower bound for position multiplier
input double MaxRiskFactor     = 2.0;    // upper bound for position multiplier

double peak_equity = 0.0;
double day_start_equity = 0.0;
datetime last_day = 0;
bool trading_allowed = true;

int OnInit()
{
   string cmd = StringFormat("/C git -C \"%s\" pull", RepoPath);
   ShellExecuteW(0, "open", "cmd.exe", cmd, NULL, 0);
   return(INIT_SUCCEEDED);
}

bool LoadSignal(datetime time,double &prob)
{
   int fh=FileOpen(ModelSignalFile,FILE_READ|FILE_CSV|FILE_ANSI);
   if(fh==INVALID_HANDLE)
      return(false);
   while(!FileIsEnding(fh))
   {
      datetime t=(datetime)FileReadString(fh);
      prob=FileReadNumber(fh);
      if(t==time)
      {
         FileClose(fh);
         return(true);
      }
   }
   FileClose(fh);
   return(false);
}

double CalculateRiskFactor()
{
   int count=MathMin(RiskLookbackBars,Bars(Symbol(),PERIOD_CURRENT)-1);
   if(count<=1)
      return(1.0);

   double mean=0.0;
   for(int i=0;i<count;i++)
      mean+=(Close[i]-Close[i+1])/Close[i+1];
   mean/=count;

   double var=0.0;
   for(int i=0;i<count;i++)
   {
      double ret=(Close[i]-Close[i+1])/Close[i+1];
      var+=MathPow(ret-mean,2);
   }
   double sd=MathSqrt(var/count);
   if(sd==0.0)
      return(1.0);

   double factor;
   if(UseSharpeSizing)
   {
      double sharpe=mean/sd;
      factor=1.0+sharpe;
   }
   else
   {
      factor=1.0/(1.0+sd*100.0);
   }

   if(factor<MinRiskFactor)
      factor=MinRiskFactor;
   if(factor>MaxRiskFactor)
      factor=MaxRiskFactor;
   return(factor);
}

void CloseAllPositions()
{
   while(PositionSelect(Symbol()))
   {
      ulong ticket=PositionGetTicket(0);
      trade.PositionClose(ticket);
   }
}

void UpdateRisk()
{
   double equity=AccountInfoDouble(ACCOUNT_EQUITY);
   if(equity>peak_equity)
      peak_equity=equity;

   datetime today=Date();
   if(today!=last_day)
   {
      day_start_equity=equity;
      last_day=today;
      trading_allowed=true;
   }

   double day_loss_pct=(equity-day_start_equity)/day_start_equity*100.0;
   double drawdown_pct=(equity-peak_equity)/peak_equity*100.0;
   if(day_loss_pct<=-MaxDailyLoss || drawdown_pct<=-MaxDrawdown)
   {
      CloseAllPositions();
      trading_allowed=false;
   }
}

void OnTick()
{
   static datetime last_time=0;
   if(TimeCurrent()==last_time)
      return;
   last_time=TimeCurrent();

   UpdateRisk();
   if(!trading_allowed)
      return;

   double prob;
   if(!LoadSignal(TimeCurrent(),prob))
      return;

   if(!PositionSelect(Symbol()) && prob>0.55)
   {
      double risk_factor=CalculateRiskFactor();
      double volume=NormalizeDouble(AccountBalance()*RiskPerTrade*risk_factor/1000,2);
      trade.Buy(volume,NULL,Ask,0,0);
   }

   if(PositionSelect(Symbol()))
   {
      ulong ticket=PositionGetTicket(0);
      double stop=PositionGetDouble(POSITION_SL);
      double price=SymbolInfoDouble(Symbol(),SYMBOL_BID);
      double new_stop=price - TrailingStopPips*_Point;
      if(new_stop>stop)
         trade.PositionModify(ticket,new_stop,0);
   }
}
